#!/usr/bin/env python

## HiC-Pro
## Copyright (c) 2015 Institut Curie                                
## Author(s): Nicolas Servant, Eric Viara
## Contact: nicolas.servant@curie.fr
## This software is distributed without any guarantee under the terms of the BSD-3 licence.
## See the LICENCE file for details

## --- Modification by Kenzo-Hugo Hillion // last 10-13-2016 ---

scriptVersion = '1.5 - 10-13-2016'

"""
Kenzo-Hugo Hillion 05-24-2016 version 1.1:

The script has been adapted to mark the Allelic status
of reads mapped on the reference genome based on the presence
of SNPs in every reads.

The script goes through all the bases of every read and check if the
position is contained in the dictionnary.

use -f option to precise it is working on the reference genome

Function added :
    -get_snps_positions(chrom, read, snps);

K-H Hillion 08-04-2016 version 1.2:

Adapt the script to deal with reads mapped with tophat2.
 -> gap for reads that overlaps junctions between exons

Modification of the following function :
    -get_mismatches_positions
        deal with mismatch at position 1
        deal with splice junction from RNA seq (skipped base in CIGAR)

K-H Hillion 08-10-2016 version 1.3:
Change strategy :
 1) Get the position of the SNP/N within the read
 2) Get the bases at the positions
 3) Get the position on the genome (takes into account splice junction and insertions)

K-H Hillion 10-10-2016 version 1.4:
Add a function to load SNP file generated by SNPsplit

K-H Hillion 10-13-2016 version 1.5:
Add an option to deal with paired-end

"""

###########  Import  ###########

import getopt
import sys
import os
import re
import pysam
import time
import gzip
import random

###########  Constant(s)  ###########

# TEMPORARY FILES
random.seed()
TMP_ID = str(random.randint(1,800000))
NSORTED_BAM = TMP_ID + "_nsort"

###########  Function(s)  ###########

def usage():
    """Usage function"""
    print "==== markAllelicStatus.py. version " + scriptVersion + " ===="
    print "Usage : python markAllelicStatus.py"
    print "-i/--ibam <BAM/SAM file of mapped reads>"
    print "-s/--snp <SNP file information - SNP file format or VCF format>"
    print "[-r/--rstat] <Generate a report with descriptive statistics>"
    print "[-t/--tag] <tag used to report allelic expression. Default XX>"
    print "[-o/--out] <output BAM file. Default is stdin>"
    print "[-f/--ref] <use reads mapped on reference genome>"
    print "[-p/--paired] <reads from paired-end sequencing>"
    print "[-n/--no_sort] <Skip the names sorting step when treating a paired-end file.\n" \
        + "                Only use if the file is already sorted by names>"
    print "[-v/--verbose] <verbose>"
    print "[-h/--help] <Help>"
    return


def get_args():
    """Get argument"""
    try:
        opts, args = getopt.getopt(
            sys.argv[1:],
            "i:s:t:o:rfpnvh",
            ["ibam=",
             "snp=",
             "tag=",
             "output=",
             "rstat", "ref", "paired", "no_sort", "verbose", "help"])
    except getopt.GetoptError as err:
        print str(err)
        usage()
        sys.exit(-1)
    return opts


def get_snp_gt(gt, ref, alt):          
    gtsnp = []
    
    ## gtsnp.append(ref)
    snp_geno = re.split('/|\|', gt)
    ## '.' are not considered
    if len(snp_geno) != 2:
        return [None,None]
    
    ## First Allele
    if int(snp_geno[0]) == 0:
        gtsnp.append(ref)
    elif int(snp_geno[0]) == 1:
        gtsnp.append(alt)
    else:
        gtsnp.append(None)
    
    ## Second Allele
    if int(snp_geno[1]) == 0:
        gtsnp.append(ref)
    elif int(snp_geno[1]) == 1:
        gtsnp.append(alt)
    else:
        gtsnp.append(None)

    return gtsnp
    


def load_vcf( in_file, filter_qual=False, verbose=False, debug=False ):
    """
    Load a VCF file in a dict object
    
    in_file = path to VCF file [character]
    filter_qual = if True, only good quality SNV are selected [boolean]
    verbose = if True, verbose mode[boolean]
    debug = if True, debug mode [boolean]
    """
    if verbose:
        print "## Loading VCF file '", in_file, "'..."

    vcf_handle = open(in_file)    
    header = []
    samples = []
    snps = {}
    var_counter = 0
    snp_counter = 0
    for line in vcf_handle:
        line = line.rstrip()
        ## for now we don't care about the header
        if line.startswith('##'):
            continue
        elif line.startswith('#'):
            header  = header = line.split('\t')            # Split by '\t' before, but the format of the generated vcf are with spaces
            header[0]    = header[0][1:]
            samples = [ s.split('.')[0] for s in header[9:] ]
            if len(samples) > 1:
                print >> sys.stderr, "Warning : Multisamples VCF detected. Only the first genotype will be used !"
            continue
        else:
            fields = line.split('\t',9)
            var_counter+=1
            n = len(fields)
            chrom = fields[0]
            start = int(fields[1])-1 ## 0-based
            ref = fields[3]
            alt = fields[4]
            qfilter = fields[6]
            ## Check format for first variant
            if var_counter == 1:
                format = fields[8] if n>8 else None
                if format.split(':')[0] != "GT":
                    print >> sys.stderr,"Error : Invalid format - GT not detected at first position in ", format         
                    sys.exit(-1)

            genotypes  = fields[9].split('\t') if fields[9] else []
            geno = get_snp_gt(genotypes[0].split(':')[0], ref, alt)      
            if filter_qual == False or (filter_qual == True and qfilter=="PASS"):
                if debug:
                    print >> sys.stderr, str(chrom) + " - " + str(start) + " - "+ str(qfilter) +" -REF= " + str(ref) + " -ALT= " + str(alt) + " - G1=" + str(geno[0]) + " - G2=" + str(geno[1])
                ## store only discriminant SNP
                if geno[0] != geno[1]:
                    snp_counter+=1
                    snps[(str(chrom), int(start), '1')] = geno[0]
                    snps[(str(chrom), int(start), '2')] = geno[1]

        if (var_counter % 100000 == 0 and verbose):
                print "##", var_counter
 
    vcf_handle.close()
    if verbose:
        print "## Number of loaded SNPs =",len(snps)/2, "over",var_counter
    return snps

def load_SNP_file(in_file, verbose=False):
    """ 
    Load a SNP file (from SNPsplit) in a dict object

    in_file = path to the SNP file [string]
    """
    # If VCF file use other function
    if in_file.endswith('.vcf'):
        return load_vcf(in_file, filter_qual=False, verbose=verbose, debug=False) 
    # Open SNP file
    elif in_file.endswith('.gz'):
        snp_handle = gzip.open(in_file,"rb")
    else:
        snp_handle = open(in_file)
    snps = {}
    var_counter = 0 
    for line in snp_handle:
        line = line.rstrip()
        var_counter += 1
        fields = line.split('\t',5)
        chrom = re.sub("^[Cc]hr","",fields[1])
        start = int(fields[2]) - 1 ## 0-based
        ref = fields[4].split('/')[0]
        alt = fields[4].split('/')[1]
        snps[(str(chrom), int(start), '1')] = ref 
        snps[(str(chrom), int(start), '2')] = alt 
        
        if (var_counter % 100000 == 0 and verbose):
            print "##", var_counter

    return snps

def get_read_tag(read, tag):
    """
    Return a read's tag

    read  = read object [class pysam.AlignedSegment]      
    tag = name of the tag to return [character]
    """
    if t[0] == tag:
        return tag[1]
    return None


def get_mismatches_positions(read, base=None):
    """
    Extract the mismatch positions within the read for all mismatches or for a specified base
    Insertion are take into account and extracted from the CIGAR string
    Mismatch positions are extracted from the MD tag
    
    read = read object [class pysam.AlignedSegment]
    base = optional - base to look at [character]

    """
    md = read.get_tag('MD')
    x = -1 ## 0-based
    npos = [] ## 0-based
    digits = []

    ## Get N pos in the read according to MD tag
    # for y in range(len(md)):
    y=0
    while y < len(md):
        if md[y].isdigit():
            digits.append(md[y])
            #print "digits="+str(md[y])
        elif not md[y].isalnum(): ## simply ignore deletion
            y += 1
            while md[y].isalpha():
                #print "isAlpha="+md[y]
                y+=1
            #x-=1
            x += int(''.join(digits))
            digits = []
            continue
        elif md[y].isalpha():
            #print "alpha="+md[y]
            if len(digits) > 0:
                offset = int(''.join(digits))
                if base is None or (base is not None and md[y] == base):
                    npos.append(x + offset + 1)
                    #print "x pos="+str(x + offset + 1)
                digits = []
                x += offset + 1
                #print "x pos="+str(x)
            else:
                if base is None or (base is not None and md[y] == base):
                    npos.append(x + 1)
                x += 1
        y+=1

    return npos


def getGenomePos(read, pos):
    """
    Go from read position to genomic position

    read = read object [class pysam.AlignedSegment]
    pos = positions to convert [list]

    """

    ## Update positions if an insertion/splice junction is detected upstream the position
    ## l is the read based position
    if ((read.cigarstring.find("I") != -1) or (read.cigarstring.find("N") != -1)):
        cig = read.cigartuples
        l = -1
        for t in cig:
            if ((t[0] == 1) or (t[0] == 3)):
                for n in range(len(pos)):
                    #print "N=" + str(npos[n]) + " l=" + str(l) + "t=" + str(t)
                    if pos[n] > l:
                        pos[n] = pos[n]+t[1]
            if int(t[0]) != 2: ## skip deletion
                l += t[1]

    ## Get genomic position
    ngenomepos = []
    if len(pos) > 0:
        for y in pos:
            #print (y)
            ngenomepos.append(y+read.pos)
    return ngenomepos

def getBaseAt(read, pos):
    """
    Extract nucleotide within a read at a given set of positions

    read = read object [class pysam.AlignedSegment]
    pos = positions to convert [list]

    """
    nuc = []
    for p in pos:
        #print (p)
        nuc.append(read.seq[(p)])
    return nuc


def getAllelicStatus(chrom, gpos, genotype, snps, debug=False):
    """
    For a given set of genomic position and assoctiated genotype, compare to a snp file and return a code status
    UA : unassigned - no snp information extracted from the read
    G1 : genotype from REF genome is found
    G2 : genotype from ALT genome is found
    CF : conflicting information extracted from the read

    gpos = genomic position to look at [list]
    genotype = read genotype [list]
    snps = snp information extracted from VCF file
    """

    code = None
    g1_count = 0
    g2_count = 0
    l = len(genotype)
    chrn = re.sub("^[Cc]hr","",chrom)

    for i in range(len(genotype)):
        #print >> sys.stderr, chrn, gpos[i], genotype[i]
        if gpos[i] != None:
            if snps.has_key((str(chrn), int(gpos[i]), '1')) and snps.has_key((str(chrn), int(gpos[i]), '2')):
                if snps[(str(chrn), int(gpos[i]), '1')] == genotype[i]:
                    g1_count+=1
                elif snps[(str(chrn), int(gpos[i]), '2')] == genotype[i]:
                    g2_count+=1
                else:
                    print >> sys.stderr, "Warning : wrong base found at position " + chrom + ":" + str(gpos[i]+1) + ". SNP ignored"

    if g1_count > 0 and g2_count > 0:
        code = "CF"
    elif g1_count > 0 and g2_count == 0:
        code = "G1"
    elif g2_count > 0 and g1_count == 0:
        code = "G2"
    elif g1_count == 0 and g2_count == 0:
        code = "UA"

    return code


def get_snps_positions(chrom, read, snps):
    """
    Extract the snp(s) positions within the read
    
    read = read object [class pysam.AlignedSegment]
    snps = snp information extracted from VCF file

    """
    chrn = re.sub("^[Cc]hr","",chrom)
    genomePos = read.pos
    npos = [] ## 0-based
    # For every position of the read, keep the position if the key exists in our SNP dictionnary
    for readPos in range(0,read.qlen):
        truePos = readPos + genomePos
        if snps.has_key((str(chrn), truePos, '1')) and snps.has_key((str(chrn), truePos, '2')):
            npos.append(readPos)

    return npos


def fragment_allelic_status(read1,read2,tag):
    """
    Compare tags between two reads and reassign correct tag for the fragment:
    UA-UA, G1-G1, G2-G2, CF-CF  -->  Nothing to change
    G1-UA, UA-G1                -->  G1,G1
    G2-UA, UA-G2                -->  G2,G2
    CF-XX, XX-CF, G1-G2, G2-G1  -->  CF,CF

    read1, read2 = read object [class pysam.AlignedSegment]
    tag = tag to compare [string]
    """
    scores = {}
    scores["UA"] = 0
    scores["G1"] = 1
    scores["G2"] = 1
    scores["CF"] = 2
    if (scores[read1.get_tag(tag)] > scores[read2.get_tag(tag)]):
        read2.set_tag(tag,read1.get_tag(tag))
    elif (scores[read1.get_tag(tag)] < scores[read2.get_tag(tag)]):
        read1.set_tag(tag,read2.get_tag(tag))
    else: # same scores
        if (read1.get_tag(tag) != read2.get_tag(tag)): # G1 and G2
            read1.set_tag(tag,"CF")
            read2.set_tag(tag,"CF")

###########  Main  ###########

if __name__ == "__main__":


    # Read command line arguments
    opts = get_args()
    inputFile = None
    verbose = False
    reference = False
    report = False
    debug = False
    paired = False
    no_sort = False
    output = "-"
    tag = "XX"
    snps={}
    
    if len(opts) == 0:
        usage()
        sys.exit()

    for opt, arg in opts:
        if opt in ("-h", "--help"):
            usage()
            sys.exit()
        elif opt in ("-s", "--snp"):
            snpFile = arg
        elif opt in ("-i", "--ibam"):
            mappedReadsFile = arg
        elif opt in ("-t", "--tag"):
            tag = arg
        elif opt in ("-o", "--out"):
            output = arg
        elif opt in ("-f", "--out"):
            reference = True
        elif opt in ("-p", "--paired"):
            paired = True
        elif opt in ("-n", "--no_sort"):
            no_sort = True
        elif opt in ("-r", "--rstat"):
            report = True
        elif opt in ("-v", "--verbose"):
            verbose = True
        else:
            assert False, "unhandled option"

    # Initialize variables
    counter_alignments = {}
    counter_alignments["READS"] = 0
    counter_alignments["UA"] = 0
    counter_alignments["G1"] = 0
    counter_alignments["G2"] = 0
    counter_alignments["CF"] = 0
    counter_alignments["UNMAPPED"] = 0
    counter_alignments["SNP"] = 0

    if (paired):
        # Initialize counters for report
        counter_pairs = {}
        counter_pairs["PROCESSED"] = {}
        counter_pairs["UA"] = {}
        counter_pairs["G1"] = {}
        counter_pairs["G2"] = {}
        counter_pairs["CF"] = {}
        for i in counter_pairs.keys():
            counter_pairs[i]["S"] = 0 # for singletons
            counter_pairs[i]["P"] = 0 # for pairs
        # Initialize variable to save previous read
        prev_read = None
        if (not no_sort):
            # Sort bam file by names
            pysam.sort("-n",mappedReadsFile,os.path.basename(mappedReadsFile) + "_" + NSORTED_BAM)

    # Read the SNP file
    snps = load_SNP_file(snpFile,verbose)
    
    # Read the SAM/BAM file
    if verbose:
        print "## Opening SAM/BAM file '", mappedReadsFile, "'..."
    if (paired and not no_sort):
        infile = pysam.Samfile(os.path.basename(mappedReadsFile) + "_" + NSORTED_BAM + ".bam", "rb")
    else:
        infile = pysam.Samfile(mappedReadsFile, "rb")

    #samOut:
    if output == "-":
        outfile = pysam.AlignmentFile(output, "w", template=infile)
    else:
        outfile = pysam.AlignmentFile(output, "wb", template=infile)
     
    # Verbose mode                                                                                                                                                        
    if verbose:
        print "## " + __file__
        print "## ibam=", mappedReadsFile
        print "## snpFile=", snpFile
        print "## tag=", tag
        print "## output=" + output 
        print "## paired=" + paired 
        print "## verbose=", verbose, "\n"

    # Reads are 0-based too (for both SAM and BAM format)
    # Loop on all reads
    if verbose:
        print "## Assigning allele specific information ..."

    for read in infile.fetch(until_eof=True):
        counter_alignments["READS"] += 1
        if not read.is_unmapped:## and read.cigarstring.find("D") != -1:
            read_chrom = infile.getrname(read.tid)
            if (reference):
                SNPreadpos = get_snps_positions(read_chrom, read, snps)     # Get the positions of the SNPs where the read mapped
            else:
                SNPreadpos = get_mismatches_positions(read, base="N")
            if (len(SNPreadpos)>0):
                #counter_alignments["SNP"] += len(Nreadpos)
                counter_alignments["SNP"] += 1         # Modified instead of previous line to count number of read covering a SNP
                SNPbase = getBaseAt(read, SNPreadpos)
                SNPreadpos = getGenomePos(read, SNPreadpos)
                tagval = getAllelicStatus(read_chrom, SNPreadpos, SNPbase, snps, debug=debug)
                read.set_tag(tag, tagval)
            
                if debug:
                    for i in range(len(SNPreadpos)):
                        if Ngenomepos[i] != None:
                            print >> sys.stderr, str(read_chrom) +"\t"+ str(Ngenomepos[i]) + "\t" + str(Ngenomepos[i]+1) + "\t" + str(read.qname) + "/N/" + str(SNPbase[i]) + "\t" + str(tagval)
                counter_alignments[tagval] += 1
            else:
                read.set_tag(tag, "UA")
                counter_alignments["UA"] += 1
        else:
            read.set_tag(tag, "UA")
            counter_alignments["UNMAPPED"] += 1
        
        if (paired):
            if prev_read is None:
                prev_read = read
            elif (read.qname == prev_read.qname): # Pair, need to compare tags
                fragment_allelic_status(read,prev_read,tag)
                counter_pairs["PROCESSED"]["P"] += 1
                counter_pairs[read.get_tag(tag)]["P"] += 1
                outfile.write(prev_read)
                outfile.write(read)
                prev_read = None
            else: # Previous read was singleton, need to write it first
                counter_pairs["PROCESSED"]["S"] += 1
                counter_pairs[prev_read.get_tag(tag)]["S"] += 1
                outfile.write(prev_read)
                prev_read = read
        else:
            outfile.write(read)

        if (counter_alignments["READS"] % 1000000 == 0 and verbose):
            print "##", counter_alignments["READS"]

 
    # Write stats file
    if report:

        handle_stat = open(re.sub(r'\.bam$|\.sam$', '.allelstat', output), 'w')
        localtime = time.asctime( time.localtime(time.time()) )
        handle_stat.write("------------------------------------------------------ \n")
        handle_stat.write("| markAllelicStatus report - " + localtime + " | \n")
        handle_stat.write("------------------------------------------------------ \n\n")

        handle_stat.write("Input parameters\n")
        handle_stat.write("================\n")
        handle_stat.write("## " + __file__ + "\n")
        handle_stat.write("## ibam=   \t" + mappedReadsFile + "\n")
        handle_stat.write("## snpFile=\t" + snpFile + "\n")
        handle_stat.write("## tag=    \t" + tag + "\n")
        handle_stat.write("## output= \t" + output + "\n")
        handle_stat.write("## paired= \t" + str(paired) + "\n")
        handle_stat.write("## reference= \t" + str(reference) + "\n")
        handle_stat.write("## verbose=\t" + str(verbose) + "\n\n")

        handle_stat.write("SNPs report\n")
        handle_stat.write("===========\n")
        handle_stat.write("Total number of snps loaded:             \t" + str(len(snps)/2) + "\n\n")

        handle_stat.write("Allele specific assignment report (per read)\n")
        handle_stat.write("============================================\n")
        handle_stat.write("Total number of reads processed          \t" + str(counter_alignments["READS"]) + " (100%)" + "\n")
        handle_stat.write("Unmapped reads                           \t" + str(counter_alignments["UNMAPPED"]) + \
          " (" + str(round(float(counter_alignments["UNMAPPED"])/int(counter_alignments["READS"])*100,3)) + "%)\n")
        if (reference):
            handle_stat.write("Number of reads with at least one SNP    \t" + str(counter_alignments["SNP"]) + \
              " (" + str(round(float(counter_alignments["SNP"])/int(counter_alignments["READS"])*100,3)) + "%)\n")
        else:
            handle_stat.write("Number of reads with at least one 'N'    \t" + str(counter_alignments["SNP"]) + \
              " (" + str(round(float(counter_alignments["SNP"])/int(counter_alignments["READS"])*100,3)) + "%)\n")
        handle_stat.write("Number of reads assigned to first genome \t" + str(counter_alignments["G1"]) + " (" + \
          str(round(float(counter_alignments["G1"])/int(counter_alignments["READS"])*100,3)) + "%)\n")
        handle_stat.write("Number of reads assigned to second genome\t" + str(counter_alignments["G2"]) + " (" + \
          str(round(float(counter_alignments["G2"])/int(counter_alignments["READS"])*100,3)) + "%)\n")
        handle_stat.write("Number of conflicting reads              \t" + str(counter_alignments["CF"]) + " (" + \
          str(round(float(counter_alignments["CF"])/int(counter_alignments["READS"])*100,3)) + "%)\n")
        handle_stat.write("Number of unassigned reads               \t" + str(counter_alignments["UA"]) + " (" + \
          str(round(float(counter_alignments["UA"])/int(counter_alignments["READS"])*100,3)) + "%)\n\n")
       
        if (paired):
            handle_stat.write("Allele specific assignment report (per pair)\n")
            handle_stat.write("============================================\n")
            handle_stat.write("Total number of pairs/singletons:    \t" + str(counter_pairs["PROCESSED"]["S"] + \
              counter_pairs["PROCESSED"]["P"]) + " (100%)\n")
            #handle_stat.write("  -Pairs:             \t" + str(counter_pairs["PROCESSED"]["P"]) + "\n")
            #handle_stat.write("  -Singletons:        \t" + str(counter_pairs["PROCESSED"]["S"]) + "\n")
            handle_stat.write("Unassignable pairs/singletons:       \t" + str(counter_pairs["UA"]["S"] + \
              counter_pairs["UA"]["P"]) + " (" + str(round(float(counter_pairs["UA"]["P"]+counter_pairs["UA"]["S"]) / \
              int(counter_pairs["PROCESSED"]["P"]+counter_pairs["PROCESSED"]["S"])*100,3)) + "%)\n")
            #handle_stat.write("  -Pairs:             \t" + str(counter_pairs["UA"]["P"]) + "\n")
            #handle_stat.write("  -Singletons:        \t" + str(counter_pairs["UA"]["S"]) + "\n")
            handle_stat.write("G1 pairs/singletons:                 \t" + str(counter_pairs["G1"]["S"] + \
              counter_pairs["G1"]["P"]) + " (" + str(round(float(counter_pairs["G1"]["P"]+counter_pairs["G1"]["S"]) / \
              int(counter_pairs["PROCESSED"]["P"]+counter_pairs["PROCESSED"]["S"])*100,3)) + "%)\n")
            #handle_stat.write("  -Pairs:             \t" + str(counter_pairs["G1"]["P"]) + "\n")
            #handle_stat.write("  -Singletons:        \t" + str(counter_pairs["G1"]["S"]) + "\n")
            handle_stat.write("G2 pairs/singletons:                 \t" + str(counter_pairs["G2"]["S"] + \
              counter_pairs["G2"]["P"]) + " (" + str(round(float(counter_pairs["G2"]["P"]+counter_pairs["G2"]["S"]) / \
              int(counter_pairs["PROCESSED"]["P"]+counter_pairs["PROCESSED"]["S"])*100,3)) + "%)\n")
            #handle_stat.write("  -Pairs:             \t" + str(counter_pairs["G2"]["P"]) + "\n")
            #handle_stat.write("  -Singletons:        \t" + str(counter_pairs["G2"]["S"]) + "\n")
            handle_stat.write("Conflicting pairs/singletons:         \t" + str(counter_pairs["CF"]["S"] + \
              counter_pairs["CF"]["P"]) + " (" + str(round(float(counter_pairs["CF"]["P"]+counter_pairs["CF"]["S"]) / \
              int(counter_pairs["PROCESSED"]["P"]+counter_pairs["PROCESSED"]["S"])*100,3)) + "%)\n")
            #handle_stat.write("  -Pairs:             \t" + str(counter_pairs["CF"]["P"]) + "\n")
            #handle_stat.write("  -Singletons:        \t" + str(counter_pairs["CF"]["S"]) + "\n")

 
        handle_stat.close()
               
             
    # Close handler
    infile.close()
    outfile.close()
    
    if (paired and not no_sort):
        os.remove(os.path.basename(mappedReadsFile) + "_" + NSORTED_BAM + ".bam")
